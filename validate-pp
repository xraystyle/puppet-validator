#!/usr/bin/ruby -w
require 'thread'
require 'pmap'

# Valid command line flags
VALID_ARGS = %w(-a -g -f -d -h --help)

# Parse ARGV[0], make sure the flag passed is valid.
unless VALID_ARGS.include? ARGV[0]
  puts "validate-pp needs a command line option" unless ARGV[0]
  puts "Invalid option: '#{ARGV[0]}'" if ARGV[0]
  puts "Use validate-pp -h for help."
  exit!
end

if %w(-h --help).include? ARGV[0]
  puts "validate-pp has five valid options:"
  puts "'-a' All. Validate any .pp files found in the current directory and all subdirectories."
  puts "'-g' Check files reported as new or modified by git, if the current directory is a valid git repo."
  puts "'-f <file-1>..<file-n>' Specify files to check, either absolute paths or relative to the working dir."
  puts "'-d <directory-1>..<directory-n>' Parse the given directories for .pp files, validate any found."
  puts "'-h' Display this help message. "
  puts
  exit!
end



# Class to represent .pp file objects.
class PuppetFile

  # This will be the work queue our thread pool pulls from
  # to validate the .pp files.
  @@all_files = Queue.new
  # Array to keep track of files that fail validation.
  @@invalid_files = []

  # return the queue of puppet files.
  def self.all_files
    @@all_files
  end
  # return the list of invalid files.
  def self.invalid_files
    @@invalid_files
  end

  attr_accessor :filename

  # Create a puppet file. All we need is the filename,
  # and to validate that it's actually a .pp file.
  def initialize(filename)
    unless File.extname(filename) == '.pp'
      puts "Error, #{filename} does not appear to be a valid puppet file."
      exit!
    end
    @filename = File.expand_path(filename.sub(' ', '\ '))
    # Add the new object to the queue.
    @@all_files.push(self)
  end
  
  # Use puppet parser to validate the puppet file.
  # if it fails validation, add it to the @@invalid_files array.
  def validate
    output = `puppet parser validate #{File.expand_path(self.filename)} 2>&1`
    if $?.exitstatus != 0
      @@invalid_files << { filename: self.filename, error: output }
    end

  end
  
end





# parse_args method figures out what we're supposed to do
# based on the command line arguments.

def parse_args

  case ARGV[0]
  when '-a'
    # check that no arg was passed with the -a flag.
    if ARGV[1]
      puts "Error, '-a' flag cannot accept additional arguments."
      puts "Run `validate-pp -h` for more info."
      exit!
    end
    parse_directory(File.expand_path(Dir.pwd))

  when '-d'
    ARGV.shift
    ARGV.each do |d|
      unless File.directory?(d)
        puts "Error, #{d} is not a directory."
        puts "Run `validate-pp -h` for more info."
        exit!
      end
    end
    ARGV.peach { |d| parse_directory(File.expand_path(d)) }

  when "-f"
    ARGV.shift
    ARGV.each do |f|
      unless File.extname(f) == '.pp'
        puts "Error, #{f} is not a '.pp' file"
        puts "Run `validate-pp -h` for more info."
        exit!
      end  
    end
    ARGV.peach { |f| PuppetFile.new(File.expand_path(f)) }

  when '-g'
    if ARGV[1]
      puts "Error, '-g' flag cannot accept additional arguments."
      puts "Run `validate-pp -h` for more info."
      exit!
    end
    parse_git_repo
  end
      
end

# Parse a given directory for .pp files and make new 
# PuppetFile instances with them.
def parse_directory(dir)
  search = File.join("**", "*.pp")
  Dir.chdir dir
  ppfiles = Dir.glob(search)
  
  ppfiles.peach do |f|
    PuppetFile.new(File.expand_path(f))
  end

end


# If the current directory is a valid git repo, get the list
# of new or modified files. Make PuppetFile instances out of the
# ones that are .pp files.
def parse_git_repo
  puts "Git repo functionality not yet implemented."
  exit!
end

# Validate the files stored in our PuppetFile files queue.
def validate_files
  workers = (0..9).map do
    Thread.new do
      begin
        while puppetfile = PuppetFile.all_files.pop(true)
          puppetfile.validate
        end
      rescue ThreadError
      end
    end
  end
  workers.map(&:join)
end



def handle_errors
  # error handling sucks right now.
  puts "\nThe following files had errors:\n\n"
  PuppetFile.invalid_files.each do |file|
    puts "File: #{file[:filename]}"
    puts file[:error]
    puts
  end
end

# -------------------------- Begin Script ---------------------------

parse_args

validate_files

handle_errors








# # Test output
# until PuppetFile.all_files.empty?

#   temp = PuppetFile.all_files.pop
#   # puts "Validating #{File.expand_path(temp.filename)}..."
#   temp.validate

# end

# puts "Invalid files: #{PuppetFile.invalid_files}"